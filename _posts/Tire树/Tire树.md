# Tire树

## 什么是Tire树

​	Tire树是一种搜索（Re**trie**val）树，又称字典树或单词查找树，此外也称前缀树，因为某个节点的后代存在共同的前缀。是一种哈希树的变种。它的key都是字符串，能做到高效查询和插入。时间复杂度O(k)，k为字符串长度。缺点是大量字符串没有共同前缀时很耗内存。它的核心思想就是减少没有必要的字符比较，使查询高效。即用空间换取时间，再利用共同前缀来提高查询效率。

## Tire特点

- 根节点不包含字符，其他节点每个节点只包含一个字符
- 从根节点到某一个节点经过的字符连起来即为该节点对应的字符串
- 每个节点的所有子节点字符都不相同

## Tire树应用

- 有一个 1 G 大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1 M。返回频数最高的100个词。
- 1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？
-  一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。
- 寻找热门查询：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。
  (1) 请描述你解决这个问题的思路；
  (2) 请给出主要的处理流程，算法，以及算法的复杂度。


## 插入操作

​	对**he、him、his、she、her、hers**六个字符串进行插入。开始插入 **he** 字符串，插入第一个字符 **h**。此时树为空，所以先创建根节点。

### 创建根节点

![](.\pic\Tire树-root.png)

### 插入he字符串

接着从根节点开始，不存在 **h** 子节点，于是创建子节点 **h** 。

![](.\pic\Tire树-h.png)

在 **h** 节点的基础上继续插入第二个字符 **e**

![](.\pic\Tire树-Page-3.png)

**h** 节点不存在 **e** 节点，创建子节点 **e**。并将该节点标记为单词标志，完成 **he** 字符串插入

![](.\pic\Tire树-Page-4.png)

### 插入him字符串

从根节点开始，发现 **h** 子节点已存在

![](.\pic\Tire树-Page-5.png)

移到到 **h** 节点

![](.\pic\Tire树-Page-6.png)

继续处理第二个字符 **i**，因为 **h** 节点不存在 **i** 子节点，于是创建 **i** 子节点

![](.\pic\Tire树-Page-7.png)

处理第三个字符 **m**，因为 **i** 节点不存在子节点 **m**，于是创建 **m** 子节点。并将该节点标记为单词标志，完成 **him** 字符串插入

![](.\pic\Tire树-Page-8.png)

### 插入his字符串

从根节点开始，发现 **h** 子节点已存在

![](.\pic\Tire树-Page-9.png)

移动到 **h**子节点

![](.\pic\Tire树-Page-10.png)

继续处理第二个字符 **i**， **h** 节点已经存在 **i** 子节点，于是移到 **i** 节点

![](.\pic\Tire树-Page-11.png)

处理第三个字符 **s**，因为 **i** 节点不存在 **s** 子节点，于是创建 **s** 子节点。并将该节点标记为单词标志，完成 **his** 插入

![](.\pic\Tire树-Page-12.png)

###  插入she字符串

从根节点开始。首先处理第一个字符 **s**，发现 **s** 子节点不存在，于是创建 **s** 节点

![](.\pic\Tire树-Page-13.png)

继续处理第二个字符 **h**，**s** 节点不存在 **h** 子节点，于是创建 **h** 节点

![](.\pic\Tire树-Page-14.png)

继续处理第三字符 **e**，因为 **h** 节点不存在 **e** 子节点，所有创建 **e** 节点，并将该节点标记为单词标志，完成 **she** 字符串的插入

![](.\pic\Tire树-Page-15.png)

### 插入her、hers字符串

依照上面的步骤，依次插入 **her** 字符和 **hers** 字符串，最终插入结果如下

![](.\pic\Tire树-Page-16.png)

## 查找操作

### 查找 **hi** 字符串

从根节点开始

![](.\pic\Tire树-Page-17.png)

根节点存在 **h** 子节点，移到到 **h** 节点

![](.\pic\Tire树-Page-18.png)

继续查找 **i**子节点，它存在，但 **i** 节点并没有单词标志，所有 **hi** 字符串不存在

![](.\pic\Tire树-Page-19.png)

### 查找his字符串

从根节点开始

![](.\pic\Tire树-Page-20.png)

根节点存在 **h** 子节点，移到 **h** 节点

![](.\pic\Tire树-Page-21.png)

**h** 节点存在 **i** 子节点，移动到 **i** 节点

![](.\pic\Tire树-Page-22.png)

**i** 节点存在 **s** 子节点，同时 **s** 节点有单词标志，找到 **his** 字符串

![](.\pic\Tire树-Page-23.png)

而如果查找 **his’** 字符串，最后的 **’** 找不到，所有不存在 **his’** 字符串

## 删除操作

### 情况1  删除she字符串

首先从根节点查找 **she** 字符串，并且找到

![](.\pic\Tire树-Page-24.png)



处理 **e** 节点，由于 **e** 节点是叶子节点，也就是说该节点没有子节点，因此删除 **e** 节点，并回退到 **h** 节点

![](.\pic\Tire树-Page-25.png)

处理 **h** 节点，由于 **h** 节点是叶子节点，也就是说该节点没有子节点，并且 **h** 节点没有单词标志，因此删除 **h** 节点，并回退到 **s** 节点

![](.\pic\Tire树-Page-26.png)

处理 **s** 节点，由于 **s** 节点是叶子节点，也就是说该节点没有子节点，并且 **s** 节点没有单词标志，因此删除 **s** 节点，并回退到根节点，此时完成删除 **she** 字符串

![](.\pic\Tire树-Page-27.png)

### 情况2 删除him字符串

首先从根节点查找 **him** 字符串，并且找到

![](.\pic\Tire树-Page-28.png)

处理 **m** 节点，由于 **m** 节点是叶子节点，也就是说该节点没有子节点，因此删除 **m** 节点，并回退到 **i** 节点

![](.\pic\Tire树-Page-29.png)

处理 **i** 节点，由于 **i** 节点存在一个子节点，因此不删除该节点，回退到 **h** 节点，同理 **h** 节点存在子节点 **i** ，到此完成删除字符串 **him**

### 情况3 删除her字符串

![](.\pic\Tire树-Page-30.png)

处理 **r** 节点，由于 **r** 节点存在子 **s** 节点，因此不删除 **r** 节点，仅仅将该节点的单词标志删除，并回退到 **e** 节点

![](.\pic\Tire树-Page-31.png)

处理 **e** 节点，由于 **e** 节点存在子节点 **r**，因此不做任何处理，并退回 **h** 节点；同理，**h** 节点存在子节点，不做处理，并退回根节点，此时完成删除 **her** 字符串

![](.\pic\Tire树-Page-32.png)